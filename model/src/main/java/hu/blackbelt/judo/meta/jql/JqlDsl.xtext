grammar hu.blackbelt.judo.meta.jql.JqlDsl hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate jqldsl "http://www.blackbelt.hu/judo/meta/jql/JqlDsl"

Expression returns Expression:
    ConcatenateExpression
    | SwitchExpression;

ConcatenateExpression returns Expression:
    OrExpression (=> ({BinaryOperation.leftOperand=current} operator=OpConcat) rightOperand=OrExpression)*;

OpConcat:
    '||';

OrExpression returns Expression:
    AndExpression (=> ({BinaryOperation.leftOperand=current} operator=OpOr) rightOperand=AndExpression)*;

OpOr:
    'or' | 'OR';

AndExpression returns Expression:
    EqualityExpression (=> ({BinaryOperation.leftOperand=current} operator=OpAnd) rightOperand=EqualityExpression)*;

OpAnd:
    'and' | 'AND';

EqualityExpression returns Expression:
    RelationalExpression (=> ({BinaryOperation.leftOperand=current} operator=OpEquality)
    rightOperand=RelationalExpression)*;

OpEquality:
    '==' | '!=';

RelationalExpression returns Expression:
    AdditiveExpression
    (=> ({BinaryOperation.leftOperand=current} operator=OpCompare) rightOperand=AdditiveExpression)*;

OpCompare:
    '>=' | '<' '=' | '>' | '<';

AdditiveExpression returns Expression:
    MultiplicativeExpression (=> ({BinaryOperation.leftOperand=current} operator=OpAdd)
    rightOperand=MultiplicativeExpression)*;

OpAdd:
    '+' | '-';

MultiplicativeExpression returns Expression:
    UnaryOperation  (=> '!' functions += Function)* (=> ({BinaryOperation.leftOperand=current} operator=OpMulti) rightOperand=UnaryOperation)*;

OpMulti:
    '*' | '/' | '%' | 'div' | 'DIV' | 'mod' | 'MOD';

UnaryOperation returns Expression:
    {UnaryOperation} operator=OpUnary operand=UnaryOperation 
        | PrimaryExpression;

OpUnary:
    "!" | 'not' | 'NOT' | "-" | "+";

ParenthesizedExpression returns Expression:
    '(' Expression ')';

PrimaryExpression returns Expression:
    ParenthesizedExpression |
    NavigationExpression |
    Literal;

LambdaExpression returns Expression:
    {LambdaExpression} argument=Feature '|' statement=Expression;

Function:
    {Function} feature=Feature ('('
    (lambda=LambdaExpression |
    (parameters+=Expression)? (',' parameters+=Expression)*)
    ')')?;

SwitchExpression returns Expression:
    {SwitchExpression} ('CASE' | 'case') operand=ConcatenateExpression body=(SwitchConditionalExpression |
    SwitchEqualsExpression);

SwitchConditionalExpression returns Expression:
    {SwitchConditionalExpression} ('AS' | 'as') alias=Feature (=> ('WHEN' | 'when') cases+=SwitchConditionalCase)* (=> ('ELSE' | 'else')
    default=Expression)?;

SwitchConditionalCase returns Expression:
    {SwitchConditionalCase} condition=RelationalExpression ('THEN' | 'then') result=Expression;

SwitchEqualsExpression returns Expression:
    {SwitchEqualsExpression} (=> ('WHEN' | 'when') cases+=SwitchEqualsCase)* (=> ('ELSE' | 'else') default=Expression)?;

SwitchEqualsCase returns Expression:
    {SwitchEqualsCase} condition=Literal ('THEN' | 'then') result=Expression;

Literal returns Expression:
    BooleanLiteral |
    NumberLiteral |
    StringLiteral |
    TemporalLiteral |
    EnumLiteral |
    MeasuredLiteral;

BooleanLiteral returns Expression:
    {BooleanLiteral} ('false' | isTrue?='true');

NumberLiteral returns Expression:
    {IntegerLiteral} value=INTEGER |
    {DecimalLiteral} value=DECIMAL;

StringLiteral returns Expression:
    {StringLiteral} value=STRING;

TemporalLiteral returns Expression:
    {DateLiteral} value=DATE |
    {TimeStampLiteral} value=TIMESTAMP;

MeasuredLiteral returns Expression:
    {MeasuredLiteral} value=NumberLiteral '[' measure=QualifiedName ']';

EnumLiteral returns Expression:
    {EnumLiteral} '`' value=QualifiedName;

NavigationExpression:
    base=NavigationBase (=> '.' features+=Feature)* ('@' cast=NavigationBase)?;

Feature:
    name=ID;

NavigationBase:
    ValidID | QualifiedName;

QualifiedName:
    ID (=> '::' ID)+;

ValidID:
    ID;

terminal DATE:
    '{' ('0'..'9' | '-')+ '}';

terminal TIMESTAMP:
    '{' ('0'..'9' | '-')+ 'T'->'}';

terminal DECIMAL returns ecore::EBigDecimal:
    INTEGER '.' INTEGER;

terminal INTEGER returns ecore::EBigInteger:
    ('0'..'9')+;

terminal ID:
    '^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal STRING:
    '"' ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | '"'))* '"' |
    "'" ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | "'"))* "'";

terminal ML_COMMENT:
    '/*'->'*/';

terminal SL_COMMENT:
    '//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
    (' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
    .;
