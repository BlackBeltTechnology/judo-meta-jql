grammar hu.blackbelt.judo.meta.jql.JqlDsl hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate jqldsl "http://www.blackbelt.hu/judo/meta/jql/JqlDsl"

Expression returns JqlExpression:
    SwitchExpression;

    // right associative rule
SwitchExpression returns JqlExpression:
    ImpliesExpression (=> ({TernaryOperation.condition=current} '?') thenExpression=SwitchExpression ':'
    elseExpression=SwitchExpression)?;

ImpliesExpression returns JqlExpression:
    OrExpression (=> ({BinaryOperation.leftOperand=current} operator='implies') rightOperand=OrExpression)*;

OrExpression returns JqlExpression:
    XorExpression (=> ({BinaryOperation.leftOperand=current} operator='or') rightOperand=XorExpression)*;

XorExpression returns JqlExpression:
    AndExpression (=> ({BinaryOperation.leftOperand=current} operator='xor') rightOperand=AndExpression)*;

AndExpression returns JqlExpression:
    EqualityExpression (=> ({BinaryOperation.leftOperand=current} operator='and') rightOperand=EqualityExpression)*;

EqualityExpression returns JqlExpression:
    RelationalExpression (=> ({BinaryOperation.leftOperand=current} operator=OpEquality)
    rightOperand=RelationalExpression)*;

OpEquality:
    '<>' | '=';

RelationalExpression returns JqlExpression:
    AdditiveExpression
    (=> ({BinaryOperation.leftOperand=current} operator=OpCompare) rightOperand=AdditiveExpression)*;

OpCompare:
    '>=' | '<' '=' | '>' | '<';

AdditiveExpression returns JqlExpression:
    MultiplicativeExpression (=> ({BinaryOperation.leftOperand=current} operator=OpAdd)
    rightOperand=MultiplicativeExpression)*;

OpAdd:
    '+' | '-';

MultiplicativeExpression returns JqlExpression:
    ExponentExpression (=> ({BinaryOperation.leftOperand=current} operator=OpMulti)
    rightOperand=ExponentExpression)*;

OpMulti:
    '*' | '/' | 'div' | 'mod';

ExponentExpression returns JqlExpression:
    UnaryOperation (=> ({BinaryOperation.leftOperand=current} operator='^')
    rightOperand=UnaryOperation)*;

UnaryOperation returns JqlExpression:
    {UnaryOperation} operator=OpUnary operand=UnaryOperation
    | PrimaryExpression (=> '!' functions+=FunctionCall)*;

OpUnary:
    'not' | "-";

ParenthesizedExpression returns JqlExpression:
    '(' Expression ')';

PrimaryExpression returns JqlExpression:
    ParenthesizedExpression |
    NavigationExpression |
    Literal;

FunctionCall:
    {FunctionCall} function=Function '(' (lambdaArgument=ValidId '|')? (parameters+=FunctionParameter (',' parameters+=FunctionParameter)*)?
    ')';

FunctionParameter:
	{FunctionParameter} expression = Expression (parameterExtension=ValidId)?;

Literal returns JqlExpression:
    BooleanLiteral |
    NumberLiteral |
    StringLiteral |
    TemporalLiteral |
    EnumLiteral |
    MeasuredLiteral;

BooleanLiteral returns JqlExpression:
    {BooleanLiteral} ('false' | isTrue?='true');

NumberLiteral returns JqlExpression:
    {IntegerLiteral} value=INTEGER |
    {DecimalLiteral} value=DECIMAL;

StringLiteral returns JqlExpression:
    {StringLiteral} value=STRING;

TemporalLiteral returns JqlExpression:
    {DateLiteral} value=DATE |
    {TimeStampLiteral} value=TIMESTAMP;

MeasuredLiteral returns JqlExpression:
    {MeasuredLiteral} value=NumberLiteral '[' (type=QualifiedName '#')? measure=ValidId ']';

EnumLiteral returns JqlExpression:
    {EnumLiteral} type=(QualifiedName)? '#' value=ValidId;

NavigationExpression:
    base=QualifiedName (=> ('.' | '=>' | '->') features+=Feature)*;

Function:
    name=ID;

Feature:
    name=ID;

QualifiedName:
    {QualifiedName} (namespaceElements+=ID '::')* name=ID
    ;

ValidId:
    ID;

terminal DATE:
    '`' ('0'..'9' | '-')+ '`';

terminal TIMESTAMP:
    '`' ('0'..'9' | '-')+ 'T'->'`';

terminal DECIMAL returns ecore::EBigDecimal:
    INTEGER '.' INTEGER;

terminal INTEGER returns ecore::EBigInteger:
    ('0'..'9')+;

terminal ID:
    '\\'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal STRING:
    '"' ('\\' . | !('\\' | '"'))* '"' |
    "'" ('\\' . | !('\\' | "'"))* "'";

terminal ML_COMMENT:
    '/*'->'*/';

terminal SL_COMMENT:
    '//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
    (' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
    .;
