= Judo Query Language

JQL is a simple expression language, which is generally independent of the queried data model.

== Syntax overview

An expression is evaluated to a single value (which of course can be a collection etc.) Newline characters are ignored in the expressions, so it is possible (and often advisable) to create multiline expression.

JQL keywords are case insensitive, so you can write the boolean `true` value as `TRUE` or `True` as well. 

=== Comments
Comments can be used to expression documentation. Two kinds of comments exist:

* Single line comments, starting with `//`
* Multiline comments, between `/\*` and `*/` characters.

=== Primitive types
JQL has the following built-in primitive types

* Boolean
* String
* Integer
* Decimal
* Date
* Timestamp

Also some expressions or expression fragments might evaluate to the special `undefined` value. `undefined` cannot be used directly.

=== Literals

==== Numeric literals

* An *integer literal* is a sequence of digits, in base 10, eg. `42`.
* A *decimal literal* represents an arbitrary precision real number: `3.14`, `100.0`

=== Boolean literal
A boolean literal is either `true` or `false`.

=== String literal
A string literal is a character sequence inside either single or double quotes, eg. `'Hello'` or `"world"`.

=== Temporal literals
* Temporal literals use backtick (```) as delimiter.
* Dates can be represented as literals using the syntax `+`2019-09-01+``.
* Timestsamps can be represented as literals using the syntax `+`2019-09-01T14:30Z+``

=== Enum literals
Use hashmark (`#`) character to denote enum literals, eg. `#MONDAY` or `model::Days#MONDAY` 

=== Identifiers

Identifiers represent names such as entities, attributes, relations. They start with letter or underscore consecuted by letters, underscore or digits.
Optionally an identifier name can be prefixed with a caret (`^`) symbol. Valid identifiers include `order`, `_order10`, `^price_rise`.

=== Operators

==== Unary operators
 
* `not`- logical negation
* `-` - arithmetical negation
 
==== Logical operators
* `=` - equals, for Strings case-insensitive comparison
* `<>` - not equals, for Strings case-insensitive comparison
* `and`- logical AND operation
* `xor` - logical XOR operation
* `or` - logical OR operation
* `implies` - logical implication operation

==== Comparison operators

* `>`, `<`, `>=`, `\<=`

==== Arithmetic operators
* `+`- addition
* `-`- substraction
* `*` integer or decimal multiplication. If either of the operands is a decimal the result is decimal.
* `/` division, the result is always a decimal number
* `mod`: integer remainder operation, both operands must be integers
* `div`: integer division operation, both operands must be integers, the result is an integer

==== String operators
* `+` - string concatenation. Note that as JQL does strong type checks, if either of the operands is not a string, the expression will be invalid.

=== Parentheses
Expressions can be parenthesized, `(1 + 2)`, `(true)`.

=== Operator precedence
(Highest precedence is 1)

. `()` (parentheses), `.` (selectors) 
. `-` (unary minus), `not` (logical negation), 
. `*`, `/`, `div`, `mod`
. `+`, `-`
. `<`, `>`, `<=`, `>=`
. `=`, `<>`
. `and`
. `xor`
. `or`
. `implies`
. `?:` ternary conditional (right-associative)


=== Qualified names

* A qualified name is an identifier followed by two colons and an other identifier `::`. Qualified names can be chained as in `Measurements::Mass::kg`.

=== Selectors
* A selector is used to access a feature (attribute, relation etc.) of an element. 
The selector operator is dot (`.`), eg. `item.price`.

== Measured values
JQL expressions support measured quantities, eg. `10[kg]`, where the measure is identified by the optionally qualified name of the measure, eg.
`10[km] + 5[model::Length#m]`

== Functions

You can use some *built-in* functions using the following syntax: `self.description!length()`

=== Numeric functions
* `round()`

=== String functions

* `lowerCase()` eg. `self.name!lowerCase()`
* `upperCase()`
* `length()`
* `substring(startIndex, endIndex)`
* `first(n)`
* `last(n)`
* `position(str)`
* `match(regex)`
* `replace(regex, replacement)`
* `trim()`

=== Date functions
* `difference(date)`

=== Timestamp functions
* `difference(timestamp)`

=== Collection functions
* `head()`
* `tail()`
* `join(delimiter)`
* `count()`
* `limit(count, offset)`
* `sort(field, descending)`

=== Lambda functions
* `filter(lambda)` eg. `self.orderDetails!filter(od | od.price 10)` 

=== Type-checking functions
* `kindof(type)`, evaluates to `true` if the given object is or a descendant of type eg. `self.field!instanceof(Lib::MyType)`
* `typeof(type)` evaluates to `true` if the given object is of type

== Type safety
JQL expressions do strict type checking.

=== Casting
The cast operator (`@`) will evaluate to the operand if its type is the same as given, otherwise evaluates as `undefined`., eg. 
`self.od@Lib::MyIntegerCollection!filter(elem | elem < 10)`

